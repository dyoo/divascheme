======================================================================
_dsyntax_ - DivaScheme syntax traversal library
======================================================================

Index terms: _dsyntax_, _divascheme_, _DivaScheme_, _dstx_, _syntax_,


dsyntax provides a _dstx_ structure that represents an
sexpression-like type, as well as utilities to traverse and do edits
on tree structure.  All of the operations here are non-destructive.



Example
-------

> (require "dsyntax.ss")
> (define a-cursor
    (let* ([a-cursor (make-toplevel-cursor '())]
           [a-cursor (cursor-insert-after a-cursor (new-atom "hello"))]
           [a-cursor (cursor-insert-after a-cursor (new-atom "this"))]
           [a-cursor (cursor-insert-after a-cursor (new-atom "is"))]
           [a-cursor (cursor-insert-after a-cursor 
                                          (new-fusion "("
                                                      (list (new-atom "a") 
                                                            (new-atom "test"))
                                                      ")"))])
      a-cursor))
> (cursor-pos a-cursor)
11
> (cursor-line a-cursor)
1
> (cursor-col a-cursor)
11
> (cursor-dstx a-cursor)
#(struct:fusion
  #(struct:object:table-from-set% ...)
  "("
  (#(struct:atom #(struct:object:table-from-set% ...) "a") 
   #(struct:atom #(struct:object:table-from-set% ...) "test"))
  ")")




API
---


A convenience module _dsyntax.ss_ module aggregates all of the
structures and API functions described below, with individual module
names for each major component commented if you want to choose modules
more selectively.



======================================================================
Data types (struct.ss)
======================================================================

We expose three main data types.

    * dstx
    * cursor
    * loc

A _dstx_ is one of the following:

    * an _atom_
    * a _space_
    * a _fusion_

A dstx roughly corresponds to the idea of an s-expression, a
tree-structure.  Both atoms and spaces represent elements without
internal structure; the distinction is that the main focusing commands
will ignore spaces and snap across them.

> dstx?: any -> boolean
> atom?: any -> boolean
> space?: any -> boolean
> fusion?: any -> boolean

> dstx-property-names: dstx -> (listof symbol)

Returns a list of the property names associated to the dstx.


> dstx-property-set: dstx symbol any -> dstx

Nondestructively associate a property name and value to a dstx.


> dstx-property-ref: dstx symbol -> any

Refers to the property with the given symbolic name.



> new-atom: string -> atom
> atom-content: atom -> string

> new-special-atom: any -> special-atom
> special-atom-content: special-atom -> any

> new-space: string -> space
> space-content: space -> string

> new-fusion: string (listof dstx) string -> fusion
> fusion-prefix: fusion -> string
> fusion-children: fusion -> (listof dstx)
> fusion-suffix: fusion -> string



_cursor_

A cursor defines our location within a dstx.  Cursors are not meant to
be constructed directly, but are to be acquired by calling
_make-toplevel-cursor_ in focus.ss.

> cursor-dstx: cursor -> dstx
> cursor-loc: cursor -> loc
> cursor-line: cursor -> number
> cursor-col: cursor -> number
> cursor-pos: cursor -> number
> cursor-endpos: cursor -> number



_loc_

A loc lets us know where we are in terms of line and column number, as
well as positionally.

> make-loc: positive-number natural-number natural-number -> loc

> loc-line: loc -> positive-number
Note: lines start counting from one.
[fixme?  Maybe we should count from zero here too?]

> loc-col: loc -> natural-number
Note: columns start counting from zero.

> loc-pos: loc -> natural-number
Note: locations start counting from zero.


======================================================================
_focus_ (focus.ss)
======================================================================


Cursors offer structured movement within a dstx.  Movement
will snap over spaces for many of these functions.


> make-toplevel-cursor: (listof dstx) -> cursor

Constructs a new cursor that's focused on the first dstx given in the
input list.  The list is assumed to be ordered in increasing
seniority.


> cursor-line: cursor -> natural-number

Returns the current line number of the focused dstx.
Line numbers start counting by 1.


> cursor-col: cursor -> natural-number

Returns the current column number at the left end of the focused dstx.
Column numbers start counting by 0.


> cursor-dstx: cursor -> dstx

Returns the focused dstx.


> focus-toplevel: cursor -> cursor

Moves the cursor back up to the first dstx at the toplevel.


> focus-in: cursor -> (union cursor #f)

Moves focus in the focused fusion to the first non-space child.  If
the focus was not in a fusion, or if the fusion has no non-space
children, returns #f.


> focus-in/no-snap: cursor -> (union cursor #f)

Moves focus in into the first child.  If the focus wasn't initially
on a fusion, returns #f.


> focus-out: cursor -> (union cursor #f)

Moves focus out to the immediate parent.  If no such parent exists,
returns #f.


> focus-older: cursor -> (union cursor #f)

Moves focus to the immediate older non-space sibling.  If no such dstx
exists, returns #f.


> focus-older/no-snap: cursor -> (union cursor #f)

Moves focus to the immediate older sibling.  If no such dstx exists,
returns #f.


> focus-younger: cursor -> (union cursor #f)

Moves focus to the immediate younger non-space sibling.  If no such
dstx exists, returns #f.


> focus-younger/no-snap: cursor -> (union cursor #f)

Moves focus to the immediate younger sibling.  If no such dstx exists,
returns #f.


> focus-successor: cursor -> (union cursor #f)

Moves focus to the non-space successor, assuming a depth-first traversal.


> focus-predecessor: cursor -> (union cursor #f)

Moves focus to the non-space predecessor, assuming a depth-first traversal.


> focus-pos: cursor number -> (union cursor #f)

> focus-line: cursor number -> (union cursor #f)

> focus-line&col: cursor number number -> (union cursor #f)



======================================================================
Editing (edit.ss)
======================================================================


> cursor-insert-before: cursor dstx -> cursor
Inserts before the current focus and moves focus to the new element.


> cursor-insert-after: cursor dstx -> cursor
Inserts after the current focus and moves focus to the new element.


> cursor-delete: cursor dstx -> cursor
[fill me in]


> cursor-set-property: cursor symbol value -> cursor
[fill me in]


======================================================================
Parsers and Pretty-Printers
======================================================================


parse-plt-scheme.ss

> parse-port: input-port -> (listof dstx)

Parses all of the dstx objects we can read off the port.



> pretty-print: dstx output-port -> void

Pretty prints the dstx to the output-port.



References
==========

DivaScheme home page: http://www.cs.brown.edu/research/plt/software/divascheme/

Ge'rard Huet. (1997) Functional Pearl: The Zipper.  J. Functional
Programming 7(5); 549-554, September 1997
