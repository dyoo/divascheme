======================================================================
_dsyntax_ - DivaScheme syntax traversal library
======================================================================

Index terms: _dsyntax_, _divascheme_, _DivaScheme_, _dstx_, _syntax_,


dsyntax provides a _dstx_ structure that represents a generalized
s-expression type.  It also provides a zipper-like "cursor" data structure
to traverse and edit dstx structure.  All of the operations here are
non-destructive.



Quick example
-------------

> (require "dsyntax.ss")
> (define a-cursor
    (let* ([a-cursor (make-toplevel-cursor '())]
           [a-cursor (insert-after a-cursor (new-atom "hello"))]
           [a-cursor (insert-after a-cursor (new-atom "this"))]
           [a-cursor (insert-after a-cursor (new-atom "is"))]
           [a-cursor (insert-after a-cursor 
                                          (new-fusion "("
                                                      (list (new-atom "a") 
                                                            (new-atom "test"))
                                                      ")"))])
      a-cursor))
> (cursor-pos a-cursor)
11
> (cursor-line a-cursor)
1
> (cursor-col a-cursor)
11
> (cursor-dstx a-cursor)
#(struct:fusion
  #(struct:object:table-from-set% ...)
  "("
  (#(struct:atom #(struct:object:table-from-set% ...) "a") 
   #(struct:atom #(struct:object:table-from-set% ...) "test"))
  ")")



Another example
---------------

> (require "dstx-text-mixin.ss")
> (define my-text (new (dstx-text-mixin text%)))
> (define c (send my-text get-dstx-cursor))
> (send c insert-after! (new-atom "hello"))
> (send c insert-after! (new-space " "))
> (send c insert-after! (new-atom "world"))
> (send my-text get-text)
"hello world"
> (send c focus-container 3)
> (send c cursor-dstx)
#(struct:atom #(struct:object:table-from-set% ...) "hello")


API
---


A convenience module _dsyntax.ss_ module aggregates all of the
structures and API functions described below, with individual module
names for each major component commented if you want to choose modules
more selectively.



======================================================================
Data types (struct.ss)
======================================================================

We expose three main data types.

    * dstx
    * cursor
    * loc



A _dstx_ is one of the following:

    * an _atom_
    * a _special-atom_
    * a _space_
    * a _fusion_

A dstx roughly corresponds to the idea of an s-expression, a
tree-structure.  Unlike a real s-expression, we preserve both comments
and whitespace. Comments are treated as atoms, and individual whitespace
characters as _space_ dstx structures.  Dstxs can also be associated with
name/value properties.

Since we often want to ignore spaces while navigating a dstx, many of the
focusing functions provided by a cursor will snap across space structs.


_dstx predicates_

> dstx?: any -> boolean
> atom?: any -> boolean
> special-atom: any -> boolean
> space?: any -> boolean
> fusion?: any -> boolean



_dstx properties_

> dstx-property-names: dstx -> (listof symbol)

Returns a list of the property names associated to the dstx.


> dstx-property-set: dstx symbol any -> dstx

Returns a new dstx with the given name/value property.


> dstx-property-ref: dstx symbol -> any

References the property with the given symbolic name.


> dstx-property-remove: dstx symbol -> dstx

Returns a dstx without the given property name binding.




_dstx constructors_

The constructors are available to build dstxs from scratch:

> new-atom: string -> atom

Creates a new atom dstx.


> new-special-atom: any -> special-atom
> new-special-atom: any number -> special-atom

Creates a new special-atom dstx.  By default, the assumed width
of a special-atom is 1.  This can be overridded by providing the optional
width parameter.


> new-space: string -> space
Creates a new space stx.


> new-fusion: string (listof dstx) string -> fusion

Creates a new fusion with the prefix, a list of children, and a suffix.
Note: fusions will always contain, as a first child, an empty string
space (new-space "") as a sentinel.


_dstx selectors_

> atom-content: atom -> string
> special-atom-content: special-atom -> any
> space-content: space -> string
> fusion-prefix: fusion -> string
> fusion-children: fusion -> (listof dstx)
> fusion-suffix: fusion -> string





_loc_

A loc lets us know where we are in terms of line and column number, as
well by position.

> make-loc: positive-number natural-number natural-number -> loc

> loc-line: loc -> positive-number
Note: lines start counting from one.
[fixme?  Maybe we should count from zero here too?]

> loc-col: loc -> natural-number
Note: columns start counting from zero.

> loc-pos: loc -> natural-number
Note: locations start counting from zero.




_cursor_

Cursors provide traversal and editing along dstxs.  A cursor defines
our location within a dstx.  Cursors are not meant to
be constructed directly, but are to be acquired by calling
_make-toplevel-cursor_ in focus.ss.

> cursor-dstx: cursor -> dstx
> cursor-loc: cursor -> loc
> cursor-line: cursor -> number
> cursor-col: cursor -> number
> cursor-pos: cursor -> number
> cursor-endpos: cursor -> number


Cursors offer structured, focused movement within a dstx.  Movement
will snap over spaces for many of these functions.


> make-toplevel-cursor: (listof dstx) -> cursor

Constructs a new cursor that's focused on the first dstx given in the
input list.  The list is assumed to be ordered in increasing
seniority.


> cursor-line: cursor -> positive-number

Returns the current line number of the focused dstx.
Line numbers start counting from 1.


> cursor-col: cursor -> natural-number

Returns the current column number at the left end of the focused dstx.
Column numbers start counting from 0.


> cursor-pos: cursor -> natural number

Returns the current position offset.  Positions start counting from 0.


> cursor-dstx: cursor -> dstx

Returns the focused dstx.


> focus-toplevel: cursor -> cursor

Moves the cursor back up to the first dstx at the toplevel.


> focus-in: cursor -> (union cursor #f)

Moves focus in the focused fusion to the first non-space child.  If
the focus was not in a fusion, or if the fusion has no non-space
children, returns #f.


> focus-in/no-snap: cursor -> (union cursor #f)

Moves focus in into the first child.  If the focus wasn't initially
on a fusion, returns #f.


> focus-out: cursor -> (union cursor #f)

Moves focus out to the immediate parent.  If no such parent exists,
returns #f.


> focus-older: cursor -> (union cursor #f)

Moves focus to the immediate older non-space sibling.  If no such dstx
exists, returns #f.


> focus-older/no-snap: cursor -> (union cursor #f)

Moves focus to the immediate older sibling.  If no such dstx exists,
returns #f.


> focus-younger: cursor -> (union cursor #f)

Moves focus to the immediate younger non-space sibling.  If no such
dstx exists, returns #f.


> focus-younger/no-snap: cursor -> (union cursor #f)

Moves focus to the immediate younger sibling.  If no such dstx exists,
returns #f.


> focus-successor: cursor -> (union cursor #f)

Moves focus to the non-space successor, assuming a depth-first traversal.


> focus-successor/no-snap: cursor -> (union cursor #f)

Moves focus to the successor, assuming a depth-first traversal.



> focus-predecessor: cursor -> (union cursor #f)

Moves focus to the non-space predecessor, assuming a depth-first traversal.


> focus-predecessor/no-snap: cursor -> (union cursor #f)

Moves focus to predecessor, assuming a depth-first traversal.



> focus-container: cursor number -> (union cursor #f)

Move focus to the enclosing dstx object of the given position.
Returns false only if the position is outside all dstxs.


> focus-find-dstx: cursor (dstx -> boolean) -> (union cursor #f)

Use the predicate to find the dstx.  Search starts from the cursor and
spreads outward toward the successors and predecessors.


> focus-pos: cursor number -> (union cursor #f)

Given a cursor and a position, refocuses the cursor at the dstx at or
immediately to the left of the cursor.  If no such syntax exists,
returns #f.  Does not snap across whitespace, except for the special
case of the sentinel empty-space character.





_editing_


> insert-before: cursor dstx -> cursor
Inserts before the current focus.  Focus moves to the new element.


> insert-after: cursor dstx -> cursor
Inserts after the current focus.  Focus moves to the new element.


> cursor-delete: cursor dstx -> cursor
Removes the currently focused dstx.  Focus moves to the immediate
older sibling of the deleted dstx if one exists, and otherwise moves to 
the immediate younger sibling.


> cursor-dstx-property-set: cursor symbol value -> cursor
Sets a new property binding onto the currently focused dstx.  Focus
stays on the dstx.


> cursor-dstx-property-get: cursor symbol -> value
Gets the property binding on the currently focused dstx.



======================================================================
Parsing and Pretty-Printing
======================================================================

We provide a sample parser for constructing dstx's out of input ports.

_parse-plt-scheme.ss_

> parse-port: input-port -> (listof dstx)

Parses all of the dstx objects we can read off the port.  Specials in the
input-port are translated to special-atom dstxs.


> pretty-print: dstx output-port -> void

Pretty prints the dstx to the output-port.
(FIXME: what happens if we try to pretty print a dstx with embedded specials?)


References
==========

DivaScheme home page: http://www.cs.brown.edu/research/plt/software/divascheme/

Ge'rard Huet. (1997) Functional Pearl: The Zipper.  J. Functional
Programming 7(5); 549-554, September 1997
